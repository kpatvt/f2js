/* demo9.f -- translated by f2c (version 20160102).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

/* Common Block Declarations */

struct {
    doublereal r4d, eodsq;
} test1_;

#define test1_1 test1_

/* Table of constant values */

static integer c__1 = 1;
static integer c__0 = 0;

/* ----------------------------------------------------------------------- */
/* Demonstration program for the DLSODIS package. */
/* This is the version of 14 June 2001. */

/* This version is in double precision. */

/* This program solves a semi-discretized form of the Burgers equation, */

/*     u  = -(u*u/2)  + eta * u */
/*      t           x          xx */

/* for  -1 .le. x .le. 1, t .ge. 0. */
/* Here eta = 0.05. */
/* Boundary conditions: u(-1,t) = u(1,t) and du/dx(-1,t) = du/dx(1,t). */
/* Initial profile: square wave */
/*     u(0,x) = 0    for 1/2 .lt. abs(x) .le. 1 */
/*     u(0,x) = 1/2  for abs(x) = 1/2 */
/*     u(0,x) = 1    for 0 .le. abs(x) .lt. 1/2 */

/* An ODE system is generated by a simplified Galerkin treatment */
/* of the spatial variable x. */

/* Reference: */
/* R. C. Y. Chin, G. W. Hedstrom, and K. E. Karlsson, */
/* A Simplified Galerkin Method for Hyperbolic Equations, */
/* Math. Comp., vol. 33, no. 146 (April 1979), pp. 647-658. */

/* The problem is run with the DLSODIS package with a 12-node mesh, */
/* for various appropriate values of the method flag mf. */
/* Output is on unit lout, set to 6 in a data statement below. */

/* Problem specific data: */
/* npts  = number of unknowns (npts = 0 mod 4) */
/* nnz   = number of non-zeros in Jacobian before fill in */
/* nnza  = number of non-zeros in Jacobian after fill in */
/* lrwk  = length of real work array (taking into account fill in) */
/* liwk  = length of integer work array */
/* ipia  = pointer to ia in iw (ia(j) = iw(ipia+j-1) */
/* ipja  = pointer to ja in iw (ja(j) = iw(ipja+j-1) */
/* ipic  = pointer to ic in iw array (ic(j) = iw(ipic+j-1)) */
/* ipjc  = pointer to jc in iw array (jc(j) = iw(ipjc+j-1)) */
/* ----------------------------------------------------------------------- */
/* Main program */ int MAIN__(void)
{
    /* Initialized data */

    static doublereal eta = .05;
    static doublereal tlast = .4;
    static doublereal tout[4] = { .1,.2,.3,.4 };
    static integer lout = 6;
    static integer nout = 4;
    static integer itol = 1;
    static doublereal rtol[2] = { .001,1e-6 };
    static doublereal atol[2] = { .001,1e-6 };
    static doublereal a = -1.;
    static doublereal b = 1.;
    static doublereal zero = 0.;
    static doublereal fourth = .25;
    static doublereal half = .5;
    static doublereal one = 1.;
    static doublereal hun = 100.;
    static doublereal tinit = 0.;

    /* Format strings */
    static char fmt_1000[] = "(20x,\002 Demonstration Program for DLSODIS"
	    "\002)";
    static char fmt_1100[] = "(//10x,\002-- Simplified Galerkin solution of"
	    " \002,\002Burgers equation --\002///13x,\002Diffusion coefficien"
	    "t is eta =\002,d10.2/13x,\002Uniform mesh on interval\002,d12.3"
	    ",\002 to \002,d12.3/13x,\002Periodic boundary conditions\002/13x,"
	    "\002Initial data are as follows:\002//20x,\002t0 = \002,d12.5/20"
	    "x,\002tlast = \002,d12.5/20x,\002n  = \002,i3//)";
    static char fmt_1200[] = "(/\002Initial profile:\002,/20(6d12.4/))";
    static char fmt_1500[] = "(///85(\002*\002)///\002Run with itol =\002,"
	    "i2,\002  rtol =\002,d12.2,\002  atol =\002,d12.2,\002   mf = "
	    "\002,i3//)";
    static char fmt_2000[] = "(\002 Output for time t =\002,d12.5,\002  curr"
	    "ent h =\002,d12.5,\002  current order =\002,i2/20(6d12.4/))";
    static char fmt_4000[] = "(/\002Final time reached for mf = \002,i3,\002"
	    " was t = \002,d12.5/25x,\002at which istate = \002,i2//)";
    static char fmt_3000[] = "(/\002Final statistics for mf = \002,i3,\002:"
	    " \002,i5,\002 steps,\002,i6,\002 res,\002,i6,\002 Jacobians,\002"
	    "/20x,\002 rw size =\002,i6,\002,    iw size =\002,i6/20x,i4,\002"
	    " extra res for each jac,\002,i4,\002 decomps\002)";
    static char fmt_5000[] = "(\002Final output is correct to within \002,d9"
	    ".2,\002  times local error tolerance.\002/)";
    static char fmt_5001[] = "(\002Final output is wrong by \002,d9.2,\002  "
	    "times local error tolerance.\002/)";
    static char fmt_6000[] = "(///85(\002*\002)//\002Run completed: number o"
	    "f errors encountered =\002,i3)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, j, n;
    static doublereal t, y[12];
    static integer mf, n14, n34, io, iw[176];
    static doublereal rw[536];
    extern /* Subroutine */ int res_();
    static integer liw, lyh, lrw, meth, nerr, moss;
    static doublereal delta;
    extern /* Subroutine */ int jacsp_();
    static integer miter;
    extern doublereal elkup_(integer *, doublereal *, doublereal *, integer *,
	     doublereal *, doublereal *, integer *);
    static doublereal ydoti[12];
    extern /* Subroutine */ int addasp_();
    static doublereal errfac;
    static integer istate;
    extern /* Subroutine */ int struct_(integer *, integer *, integer *, 
	    integer *, integer *), dlsodis_(U_fp, U_fp, U_fp, integer *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     doublereal *, doublereal *, integer *, integer *, integer *, 
	    doublereal *, integer *, integer *, integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___26 = { 0, 0, 0, fmt_1000, 0 };
    static cilist io___27 = { 0, 0, 0, fmt_1100, 0 };
    static cilist io___28 = { 0, 0, 0, fmt_1200, 0 };
    static cilist io___37 = { 0, 0, 0, fmt_1500, 0 };
    static cilist io___41 = { 0, 0, 0, fmt_2000, 0 };
    static cilist io___42 = { 0, 0, 0, fmt_4000, 0 };
    static cilist io___43 = { 0, 0, 0, fmt_3000, 0 };
    static cilist io___46 = { 0, 0, 0, fmt_5000, 0 };
    static cilist io___47 = { 0, 0, 0, fmt_5001, 0 };
    static cilist io___48 = { 0, 0, 0, fmt_6000, 0 };



/* Pass problem parameters in the Common block test1. */

/* Set problem parameters and run parameters */

    nerr = 0;
    lrw = 536;
    liw = 176;

/* Compute the mesh width delta and other parameters. */
    delta = (b - a) / 12;
    test1_1.r4d = fourth / delta;
/* Computing 2nd power */
    d__1 = delta;
    test1_1.eodsq = eta / (d__1 * d__1);
    n14 = 4;
    n34 = 10;
    n = 12;

/* Set the initial profile (for output purposes only). */
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__ - 1] = zero;
    }
    y[n14 - 1] = half;
    i__1 = n34 - 1;
    for (i__ = n14 + 1; i__ <= i__1; ++i__) {
/* L20: */
	y[i__ - 1] = one;
    }
    y[n34 - 1] = half;

    io___26.ciunit = lout;
    s_wsfe(&io___26);
    e_wsfe();
    io___27.ciunit = lout;
    s_wsfe(&io___27);
    do_fio(&c__1, (char *)&eta, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&a, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&b, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&tinit, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&tlast, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
    e_wsfe();
    io___28.ciunit = lout;
    s_wsfe(&io___28);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	do_fio(&c__1, (char *)&y[i__ - 1], (ftnlen)sizeof(doublereal));
    }
    e_wsfe();

/* Set the initial sparse data structures for coefficient matrix A */
/* and the Jacobian matrix C */
    struct_(&iw[30], &iw[43], &iw[79], &iw[92], &n);

/* The j loop is over error tolerances. */
    for (j = 1; j <= 2; ++j) {

/* This method flag loop is for demonstration only. */
	for (moss = 0; moss <= 4; ++moss) {
	    for (meth = 1; meth <= 2; ++meth) {
		for (miter = 1; miter <= 2; ++miter) {
/* L35: */
		    mf = moss * 100 + meth * 10 + miter;

/* Set the initial profile. */
		    i__1 = n;
		    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
			y[i__ - 1] = zero;
		    }
		    y[n14 - 1] = half;
		    i__1 = n34 - 1;
		    for (i__ = n14 + 1; i__ <= i__1; ++i__) {
/* L50: */
			y[i__ - 1] = one;
		    }
		    y[n34 - 1] = half;

		    t = tinit;
		    istate = 0;

		    io___37.ciunit = lout;
		    s_wsfe(&io___37);
		    do_fio(&c__1, (char *)&itol, (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&rtol[j - 1], (ftnlen)sizeof(
			    doublereal));
		    do_fio(&c__1, (char *)&atol[j - 1], (ftnlen)sizeof(
			    doublereal));
		    do_fio(&c__1, (char *)&mf, (ftnlen)sizeof(integer));
		    e_wsfe();

/* output loop for each case */
		    i__1 = nout;
		    for (io = 1; io <= i__1; ++io) {

/* Call DLSODIS and print results. */
			dlsodis_((U_fp)res_, (U_fp)addasp_, (U_fp)jacsp_, &n, 
				y, ydoti, &t, &tout[io - 1], &itol, &rtol[j - 
				1], &atol[j - 1], &c__1, &istate, &c__0, rw, &
				lrw, iw, &liw, &mf);
			io___41.ciunit = lout;
			s_wsfe(&io___41);
			do_fio(&c__1, (char *)&t, (ftnlen)sizeof(doublereal));
			do_fio(&c__1, (char *)&rw[10], (ftnlen)sizeof(
				doublereal));
			do_fio(&c__1, (char *)&iw[13], (ftnlen)sizeof(integer)
				);
			i__2 = n;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    do_fio(&c__1, (char *)&y[i__ - 1], (ftnlen)sizeof(
				    doublereal));
			}
			e_wsfe();

/* If istate is not 2 on return, print message and go to next case. */
			if (istate != 2) {
			    io___42.ciunit = lout;
			    s_wsfe(&io___42);
			    do_fio(&c__1, (char *)&mf, (ftnlen)sizeof(integer)
				    );
			    do_fio(&c__1, (char *)&t, (ftnlen)sizeof(
				    doublereal));
			    do_fio(&c__1, (char *)&istate, (ftnlen)sizeof(
				    integer));
			    e_wsfe();
			    ++nerr;
			    goto L100;
			}
/* L80: */
		    }
		    io___43.ciunit = lout;
		    s_wsfe(&io___43);
		    do_fio(&c__1, (char *)&mf, (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[10], (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[11], (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[12], (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[16], (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[17], (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[19], (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iw[20], (ftnlen)sizeof(integer));
		    e_wsfe();

/* Estimate final error and print result. */
		    lyh = iw[21];
		    errfac = elkup_(&n, y, &rw[lyh - 1], &itol, &rtol[j - 1], 
			    &atol[j - 1], &lout);
		    if (errfac < hun) {
			io___46.ciunit = lout;
			s_wsfe(&io___46);
			do_fio(&c__1, (char *)&errfac, (ftnlen)sizeof(
				doublereal));
			e_wsfe();
		    } else {
			io___47.ciunit = lout;
			s_wsfe(&io___47);
			do_fio(&c__1, (char *)&errfac, (ftnlen)sizeof(
				doublereal));
			e_wsfe();
			++nerr;
		    }
L100:
		    ;
		}
	    }
/* L200: */
	}
    }

    io___48.ciunit = lout;
    s_wsfe(&io___48);
    do_fio(&c__1, (char *)&nerr, (ftnlen)sizeof(integer));
    e_wsfe();
    s_stop("", (ftnlen)0);







/* end of main program for the DLSODIS demonstration program */
    return 0;
} /* MAIN__ */

/* Subroutine */ int struct_(integer *ia, integer *ja, integer *ic, integer *
	jc, integer *n)
{
    /* Format strings */
    static char fmt_1200[] = "(\002Initial sparse data structures\002/)";
    static char fmt_1300[] = "(\002 ia  \002,15i4/10(5x,15i4/))";
    static char fmt_1350[] = "(\002 ja  \002,15i4/10(5x,15i4/))";
    static char fmt_1400[] = "(\002 ic  \002,15i4/10(5x,15i4/))";
    static char fmt_1450[] = "(\002 jc  \002,15i4/10(5x,15i4/))";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer k, l, m, jj;

    /* Fortran I/O blocks */
    static cilist io___49 = { 0, 6, 0, fmt_1200, 0 };
    static cilist io___53 = { 0, 6, 0, fmt_1300, 0 };
    static cilist io___55 = { 0, 6, 0, fmt_1350, 0 };
    static cilist io___56 = { 0, 6, 0, fmt_1400, 0 };
    static cilist io___57 = { 0, 6, 0, fmt_1450, 0 };


/* This subroutine computes the initial sparse data structure of */
/* the mass (ia,ja) and Jacobian (ic,jc) matrices. */


    /* Parameter adjustments */
    --jc;
    --ic;
    --ja;
    --ia;

    /* Function Body */
    s_wsfe(&io___49);
    e_wsfe();
    k = 0;
    i__1 = *n;
    for (l = 1; l <= i__1; ++l) {
	ia[l] = (l - 1) * 3 + 1;
	ic[l] = (l - 1) * 3 + 1;
	i__2 = l + 2;
	for (m = l; m <= i__2; ++m) {
	    ++k;
	    ja[k] = m - 1;
	    jc[k] = m - 1;
/* L32: */
	}
/* L33: */
    }
    ia[*n + 1] = *n * 3 + 1;
    ic[*n + 1] = *n * 3 + 1;
    ja[1] = *n;
    jc[1] = *n;
    ja[k] = 1;
    jc[k] = 1;

    s_wsfe(&io___53);
    i__1 = *n + 1;
    for (jj = 1; jj <= i__1; ++jj) {
	do_fio(&c__1, (char *)&ia[jj], (ftnlen)sizeof(integer));
    }
    e_wsfe();
    s_wsfe(&io___55);
    i__1 = k;
    for (jj = 1; jj <= i__1; ++jj) {
	do_fio(&c__1, (char *)&ja[jj], (ftnlen)sizeof(integer));
    }
    e_wsfe();
    s_wsfe(&io___56);
    i__1 = *n + 1;
    for (jj = 1; jj <= i__1; ++jj) {
	do_fio(&c__1, (char *)&ic[jj], (ftnlen)sizeof(integer));
    }
    e_wsfe();
    s_wsfe(&io___57);
    i__1 = k;
    for (jj = 1; jj <= i__1; ++jj) {
	do_fio(&c__1, (char *)&jc[jj], (ftnlen)sizeof(integer));
    }
    e_wsfe();
    return 0;
} /* struct_ */

/* Subroutine */ int res_(integer *n, doublereal *t, doublereal *y, 
	doublereal *v, doublereal *r__, integer *ires)
{
    /* Initialized data */

    static doublereal one = 1.;
    static doublereal four = 4.;
    static doublereal six = 6.;

    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int gfun_(integer *, doublereal *, doublereal *, 
	    doublereal *);
    static doublereal fact1, fact4;

/* This subroutine computes the residual vector */
/*   r = g(t,y) - A(t,y)*v . */
/* If ires = -1, only g(t,y) is returned in r, since A(t,y) does */
/* not depend on y. */
/* No changes need to be made to this routine if n is changed. */

    /* Parameter adjustments */
    --r__;
    --v;
    --y;

    /* Function Body */

    gfun_(n, t, &y[1], &r__[1]);
    if (*ires == -1) {
	return 0;
    }

    fact1 = one / six;
    fact4 = four / six;

    r__[1] -= fact4 * v[1] + fact1 * (v[2] + v[*n]);
    i__1 = *n - 1;
    for (i__ = 2; i__ <= i__1; ++i__) {
	r__[i__] -= fact4 * v[i__] + fact1 * (v[i__ - 1] + v[i__ + 1]);
/* L10: */
    }
    r__[*n] -= fact4 * v[*n] + fact1 * (v[1] + v[*n - 1]);
    return 0;
/* end of subroutine res for the DLSODIS demonstration program */
} /* res_ */

/* Subroutine */ int gfun_(integer *n, doublereal *t, doublereal *y, 
	doublereal *g)
{
    /* Initialized data */

    static doublereal two = 2.;

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__;

/* This subroutine computes the right-hand side function g(y,t). */
/* It uses r4d = 1/(4*delta) and eodsq = eta/delta**2 */
/* from the Common block test1. */

    /* Parameter adjustments */
    --g;
    --y;

    /* Function Body */

/* Computing 2nd power */
    d__1 = y[(0 + (0 + (*n << 3))) / 8];
/* Computing 2nd power */
    d__2 = y[2];
    g[1] = test1_1.r4d * (d__1 * d__1 - d__2 * d__2) + test1_1.eodsq * (y[2] 
	    - two * y[1] + y[(0 + (0 + (*n << 3))) / 8]);

    i__1 = *n - 1;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* Computing 2nd power */
	d__1 = y[i__ - 1];
/* Computing 2nd power */
	d__2 = y[i__ + 1];
	g[i__] = test1_1.r4d * (d__1 * d__1 - d__2 * d__2) + test1_1.eodsq * (
		y[i__ + 1] - two * y[i__] + y[i__ - 1]);
/* L20: */
    }

/* Computing 2nd power */
    d__1 = y[*n - 1];
/* Computing 2nd power */
    d__2 = y[1];
    g[*n] = test1_1.r4d * (d__1 * d__1 - d__2 * d__2) + test1_1.eodsq * (y[1] 
	    - two * y[*n] + y[*n - 1]);

    return 0;
/* end of subroutine gfun for the DLSODIS demonstration program */
} /* gfun_ */

/* Subroutine */ int addasp_(integer *n, doublereal *t, doublereal *y, 
	integer *j, integer *ip, integer *jp, doublereal *pa)
{
    /* Initialized data */

    static doublereal one = 1.;
    static doublereal four = 4.;
    static doublereal six = 6.;

    static integer jm1, jp1;
    static doublereal fact1, fact4;

/* This subroutine computes the sparse matrix A by columns, adds it to */
/* pa, and returns the sum in pa. */
/* The matrix A is periodic tridiagonal, of order n, with nonzero elements */
/* (reading across) of  1/6, 4/6, 1/6, with 1/6 in the lower left and */
/* upper right corners. */

    /* Parameter adjustments */
    --pa;
    --y;
    --ip;
    --jp;

    /* Function Body */

/* Compute the elements of A. */
    fact1 = one / six;
    fact4 = four / six;
    jm1 = *j - 1;
    jp1 = *j + 1;
    if (*j == *n) {
	jp1 = 1;
    }
    if (*j == 1) {
	jm1 = *n;
    }

/* Add the matrix A to the matrix pa (sparse). */
    pa[*j] += fact4;
    pa[jp1] += fact1;
    pa[jm1] += fact1;
    return 0;
/* end of subroutine addasp for the DLSODIS demonstration program */
} /* addasp_ */

/* Subroutine */ int jacsp_(integer *n, doublereal *t, doublereal *y, 
	doublereal *s, integer *j, integer *ip, integer *jp, doublereal *pdj)
{
    /* Initialized data */

    static doublereal two = 2.;

    static integer jm1;
    static doublereal r2d;
    static integer jp1;
    static doublereal diag;

/* This subroutine computes the Jacobian dg/dy = d(g-A*s)/dy by */
/* columns in sparse matrix format.  Only nonzeros are loaded. */
/* It uses r4d = 1/(4*delta) and eodsq = eta/delta**2 from the Common */
/* block test1. */

    /* Parameter adjustments */
    --pdj;
    --s;
    --y;
    --ip;
    --jp;

    /* Function Body */

    diag = -two * test1_1.eodsq;
    r2d = two * test1_1.r4d;
    jm1 = *j - 1;
    jp1 = *j + 1;
    if (*j == 1) {
	jm1 = *n;
    }
    if (*j == *n) {
	jp1 = 1;
    }

    pdj[jm1] = -r2d * y[*j] + test1_1.eodsq;
    pdj[*j] = diag;
    pdj[jp1] = r2d * y[*j] + test1_1.eodsq;
    return 0;
/* end of subroutine jacsp for the DLSODIS demonstration program */
} /* jacsp_ */

doublereal elkup_(integer *n, doublereal *y, doublereal *ewt, integer *itol, 
	doublereal *rtol, doublereal *atol, integer *lout)
{
    /* Initialized data */

    static doublereal y12[12] = { .016058186,.0323063251,.12190338,.270943828,
	    .460951522,.657571216,.825154453,.935644796,.990167557,.922421221,
	    .585764902,.181112615 };
    static struct {
	doublereal e_1[120];
	} equiv_7 = { .0189009068, .0163261891, .0147080563, .0139263623, 
		.0138901341, .0145336989, .0158129308, .0177017162, 
		.0201886844, .0232742221, .0269677715, .0312854037, 
		.0362476563, .0418776225, .0481992825, .0552360652, 
		.0630096338, .0715388849, .0808391507, .0909215944, 
		.101792784, .113454431, .125903273, .139131085, .153124799, 
		.167866712, .183334757, .19950283, .216341144, .2338166, 
		.251893167, .270532241, .289693007, .309332757, .329407198, 
		.349870723, .370676646, .391777421, .413124817, .434670077, 
		.456364053, .478157319, .50000027, .521843218, .543636473, 
		.565330432, .58687567, .608223037, .629323777, .650129662, 
		.670593142, .690667536, .710307235, .729467947, .748106966, 
		.766183477, .783658878, .800497138, .816665158, .832133153, 
		.846875019, .860868691, .874096465, .886545273, .898206892, 
		.90907806, .919160487, .928460742, .936989986, .944763554, 
		.951800339, .958122004, .963751979, .968714242, .973031887, 
		.976725449, .979811001, .982297985, .984186787, .985466039, 
		.986109629, .986073433, .985291781, .983673704, .981099057, 
		.977414704, .972431015, .965919133, .957609585, .947193093, 
		.934324619, .918631922, .899729965, .877242371, .850830623, 
		.820230644, .785294781, .746035145, .702662039, .655609682, 
		.605541326, .55332795, .499999118, .446670394, .394457322, 
		.34438941, .297337561, .253964948, .214705729, .179770169, 
		.149170367, .122758681, .100271052, .081368992, .0656761515, 
		.052807516, .0423908624, .034081165, .0275691506, .0225853507 
		};


    /* Format strings */
    static char fmt_400[] = "(/5x,\002Illegal use of elkup for n =\002,i4)";

    /* System generated locals */
    doublereal ret_val;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__;
#define y120 ((doublereal *)&equiv_7)
#define y120a ((doublereal *)&equiv_7)
#define y120b ((doublereal *)&equiv_7 + 16)
#define y120c ((doublereal *)&equiv_7 + 32)
#define y120d ((doublereal *)&equiv_7 + 48)
#define y120e ((doublereal *)&equiv_7 + 64)
#define y120f ((doublereal *)&equiv_7 + 80)
#define y120g ((doublereal *)&equiv_7 + 96)
#define y120h ((doublereal *)&equiv_7 + 112)
    extern /* Subroutine */ int dewset_(integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *);
    extern doublereal dvnorm_(integer *, doublereal *, doublereal *);

    /* Fortran I/O blocks */
    static cilist io___89 = { 0, 0, 0, fmt_400, 0 };


/* This routine looks up approximately correct values of y at t = 0.4, */
/* ytrue = y12 or y120 depending on whether n = 12 or 120. */
/* These were obtained by running with very tight tolerances. */
/* The returned value is */
/*   elkup = norm of [ (y - ytrue) / (rtol*abs(ytrue) + atol) ]. */

    /* Parameter adjustments */
    --ewt;
    --y;

    /* Function Body */

    if ((*n - 12) * (*n - 120) != 0) {
	goto L300;
    }
    if (*n == 120) {
	goto L100;
    }

/* Compute local error tolerance using correct y (n = 12). */
    dewset_(n, itol, rtol, atol, y12, &ewt[1]);

/* Invert ewt and replace y by the error, y - ytrue. */
    for (i__ = 1; i__ <= 12; ++i__) {
	ewt[i__] = 1. / ewt[i__];
/* L20: */
	y[i__] -= y12[i__ - 1];
    }
    goto L200;

/* Compute local error tolerance using correct y (n = 120). */
L100:
    dewset_(n, itol, rtol, atol, y120, &ewt[1]);

/* Invert ewt and replace y by the error, y - ytrue. */
    for (i__ = 1; i__ <= 120; ++i__) {
	ewt[i__] = 1. / ewt[i__];
/* L120: */
	y[i__] -= y120[i__ - 1];
    }

/* Find weighted norm of the error. */
L200:
    ret_val = dvnorm_(n, &y[1], &ewt[1]);
    return ret_val;

/* error return */
L300:
    io___89.ciunit = *lout;
    s_wsfe(&io___89);
    do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
    e_wsfe();
    ret_val = 1e3;
    return ret_val;
/* end of function elkup for the DLSODIS demonstration program */
} /* elkup_ */

#undef y120h
#undef y120g
#undef y120f
#undef y120e
#undef y120d
#undef y120c
#undef y120b
#undef y120a
#undef y120


