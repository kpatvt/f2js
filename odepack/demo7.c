/* demo7.f -- translated by f2c (version 20160102).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

/* Common Block Declarations */

struct {
    doublereal r4d, eodsq;
    integer nm1;
} test1_;

#define test1_1 test1_

/* Table of constant values */

static integer c__1 = 1;
static integer c__0 = 0;

/* ----------------------------------------------------------------------- */
/* Demonstration program for the DLSODI package. */
/* This is the version of 14 June 2001. */

/* This version is in double precision. */

/* this program solves a semi-discretized form of the Burgers equation, */

/*     u  = -(u*u/2)  + eta * u */
/*      t           x          xx */

/* for a = -1 .le. x .le. 1 = b, t .ge. 0. */
/* Here eta = 0.05. */
/* Boundary conditions: u(-1,t) = u(1,t) = 0. */
/* Initial profile: square wave */
/*     u(0,x) = 0    for 1/2 .lt. abs(x) .le. 1 */
/*     u(0,x) = 1/2  for abs(x) = 1/2 */
/*     u(0,x) = 1    for 0 .le. abs(x) .lt. 1/2 */

/* An ODE system is generated by a simplified Galerkin treatment */
/* of the spatial variable x. */

/* Reference: */
/* R. C. Y. Chin, G. W. Hedstrom, and K. E. Karlsson, */
/* A Simplified Galerkin Method for Hyperbolic Equations, */
/* Math. Comp., vol. 33, no. 146 (April 1979), pp. 647-658. */

/* The problem is run with the DLSODI package with a 10-point mesh */
/* and a 100-point mesh.  In each case, it is run with two tolerances */
/* and for various appropriate values of the method flag mf. */
/* Output is on unit lout, set to 6 in a data statement below. */
/* ----------------------------------------------------------------------- */
/* Main program */ int MAIN__(void)
{
    /* Initialized data */

    static doublereal eta = .05;
    static doublereal tlast = .4;
    static doublereal tout[4] = { .1,.2,.3,.4 };
    static integer ml = 1;
    static integer mu = 1;
    static integer lout = 6;
    static integer nout = 4;
    static integer lrw = 2002;
    static integer liw = 125;
    static integer itol = 1;
    static doublereal rtol[2] = { .001,1e-6 };
    static doublereal a = -1.;
    static doublereal atol[2] = { .001,1e-6 };
    static doublereal b = 1.;
    static doublereal zero = 0.;
    static doublereal fourth = .25;
    static doublereal half = .5;
    static doublereal one = 1.;
    static doublereal hun = 100.;
    static doublereal tinit = 0.;

    /* Format strings */
    static char fmt_1010[] = "(///80(\002*\002)///)";
    static char fmt_1000[] = "(20x,\002 Demonstration Problem for DLSODI\002)"
	    ;
    static char fmt_1100[] = "(/10x,\002 Simplified Galerkin Solution of Bur"
	    "gers Equation\002//13x,\002Diffusion coefficient is eta =\002,d1"
	    "0.2/13x,\002Uniform mesh on interval\002,d12.3,\002 to \002,d12."
	    "3/13x,\002Zero boundary conditions\002/13x,\002Time limits: t0 = "
	    "\002,d12.5,\002   tlast = \002,d12.5/13x,\002Half-bandwidths ml "
	    "= \002,i2,\002   mu = \002,i2/13x,\002System size neq = \002,i3/)"
	    ;
    static char fmt_1200[] = "(\002Initial profile:\002/17(6d12.4/))";
    static char fmt_1500[] = "(///80(\002-\002)///\002Run with rtol =\002,d1"
	    "2.2,\002  atol =\002,d12.2,\002   mf =\002,i3,\002   npts =\002,"
	    "i4,\002:\002//)";
    static char fmt_2000[] = "(\002Output for time t = \002,d12.5,\002   cur"
	    "rent h =\002,d12.5,\002   current order =\002,i2,\002:\002/17(6d"
	    "12.4/))";
    static char fmt_4000[] = "(///80(\002*\002)//20x,\002Final time reached "
	    "for mf = \002,i2,\002 was t = \002,d12.5/25x,\002at which istate"
	    " = \002,i2////80(\002*\002))";
    static char fmt_3000[] = "(//\002Final statistics for mf = \002,i2,\002"
	    ":\002/i4,\002 steps,\002,i5,\002 res,\002,i4,\002 Jacobians,\002,"
	    "\002   rwork size =\002,i6,\002,   iwork size =\002,i6)";
    static char fmt_5001[] = "(\002  Final output is wrong by \002,d8.1,\002"
	    "  times local error tolerance\002)";
    static char fmt_5000[] = "(\002  Final output is correct to within \002,"
	    "d8.1,\002  times local error tolerance\002)";
    static char fmt_6000[] = "(//80(\002*\002)//\002Run completed.  Number o"
	    "f errors encountered =\002,i3)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, j, n;
    static doublereal t, y[99];
    static integer mf, n14, n34, io;
    extern /* Subroutine */ int res_();
    static integer n14m1, n34m1, n14p1, n34p1, meth, nerr, npts;
    extern /* Subroutine */ int jacbd_(), jacfl_();
    static doublereal delta;
    static integer miter;
    extern doublereal elkup_(integer *, doublereal *, doublereal *, integer *,
	     doublereal *, doublereal *);
    static doublereal ydoti[99];
    static integer iwork[125];
    static doublereal rwork[2002];
    extern /* Subroutine */ int addabd_(), addafl_();
    static integer nptsm1;
    static doublereal errfac;
    extern /* Subroutine */ int dlsodi_(U_fp, U_fp, U_fp, integer *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     doublereal *, doublereal *, integer *, integer *, integer *, 
	    doublereal *, integer *, integer *, integer *, integer *);
    static integer istate;

    /* Fortran I/O blocks */
    static cilist io___35 = { 0, 0, 0, fmt_1010, 0 };
    static cilist io___36 = { 0, 0, 0, fmt_1000, 0 };
    static cilist io___37 = { 0, 0, 0, fmt_1100, 0 };
    static cilist io___38 = { 0, 0, 0, fmt_1200, 0 };
    static cilist io___45 = { 0, 0, 0, fmt_1500, 0 };
    static cilist io___49 = { 0, 0, 0, fmt_2000, 0 };
    static cilist io___50 = { 0, 0, 0, fmt_4000, 0 };
    static cilist io___51 = { 0, 0, 0, fmt_3000, 0 };
    static cilist io___53 = { 0, 0, 0, fmt_5001, 0 };
    static cilist io___54 = { 0, 0, 0, fmt_5000, 0 };
    static cilist io___55 = { 0, 0, 0, fmt_6000, 0 };


/* Pass problem parameters in the Common block test1. */

/* Set problem parameters and run parameters */

    iwork[0] = ml;
    iwork[1] = mu;
    nerr = 0;

/* Loop over two values of npts. */
    for (npts = 10; npts <= 100; npts += 90) {

/* Compute the mesh width delta and other parameters. */
	delta = (b - a) / npts;
	test1_1.r4d = fourth / delta;
/* Computing 2nd power */
	d__1 = delta;
	test1_1.eodsq = eta / (d__1 * d__1);
	nptsm1 = npts - 1;
	n14 = npts / 4;
	n34 = n14 * 3;
	n14m1 = n14 - 1;
	n14p1 = n14m1 + 2;
	n34m1 = n34 - 1;
	n34p1 = n34m1 + 2;
	n = nptsm1;
	test1_1.nm1 = n - 1;

/* Set the initial profile (for output purposes only). */

	i__1 = n14m1;
	for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	    y[i__ - 1] = zero;
	}
	y[n14 - 1] = half;
	i__1 = n34m1;
	for (i__ = n14p1; i__ <= i__1; ++i__) {
/* L20: */
	    y[i__ - 1] = one;
	}
	y[n34 - 1] = half;
	i__1 = nptsm1;
	for (i__ = n34p1; i__ <= i__1; ++i__) {
/* L30: */
	    y[i__ - 1] = zero;
	}

	if (npts > 10) {
	    io___35.ciunit = lout;
	    s_wsfe(&io___35);
	    e_wsfe();
	}
	io___36.ciunit = lout;
	s_wsfe(&io___36);
	e_wsfe();
	io___37.ciunit = lout;
	s_wsfe(&io___37);
	do_fio(&c__1, (char *)&eta, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&a, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&b, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tinit, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&tlast, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&ml, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&mu, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
	e_wsfe();
	io___38.ciunit = lout;
	s_wsfe(&io___38);
	do_fio(&c__1, (char *)&zero, (ftnlen)sizeof(doublereal));
	i__1 = n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    do_fio(&c__1, (char *)&y[i__ - 1], (ftnlen)sizeof(doublereal));
	}
	do_fio(&c__1, (char *)&zero, (ftnlen)sizeof(doublereal));
	e_wsfe();

/* The j loop is over error tolerances. */

	for (j = 1; j <= 2; ++j) {

/* Loop over method flag loop (for demonstration). */

	    for (meth = 1; meth <= 2; ++meth) {
		for (miter = 1; miter <= 5; ++miter) {
		    if (miter == 3) {
			goto L100;
		    }
		    if (miter <= 2 && npts > 10) {
			goto L100;
		    }
		    if (miter == 5 && npts < 100) {
			goto L100;
		    }
		    mf = meth * 10 + miter;

/* Set the initial profile. */

		    i__1 = n14m1;
		    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
			y[i__ - 1] = zero;
		    }
		    y[n14 - 1] = half;
		    i__1 = n34m1;
		    for (i__ = n14p1; i__ <= i__1; ++i__) {
/* L50: */
			y[i__ - 1] = one;
		    }
		    y[n34 - 1] = half;
		    i__1 = nptsm1;
		    for (i__ = n34p1; i__ <= i__1; ++i__) {
/* L60: */
			y[i__ - 1] = zero;
		    }

		    t = tinit;
		    istate = 0;

		    io___45.ciunit = lout;
		    s_wsfe(&io___45);
		    do_fio(&c__1, (char *)&rtol[j - 1], (ftnlen)sizeof(
			    doublereal));
		    do_fio(&c__1, (char *)&atol[j - 1], (ftnlen)sizeof(
			    doublereal));
		    do_fio(&c__1, (char *)&mf, (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&npts, (ftnlen)sizeof(integer));
		    e_wsfe();

/*  Output loop for each case */

		    i__1 = nout;
		    for (io = 1; io <= i__1; ++io) {

/*         call DLSODI */
			if (miter <= 2) {
			    dlsodi_((U_fp)res_, (U_fp)addafl_, (U_fp)jacfl_, &
				    n, y, ydoti, &t, &tout[io - 1], &itol, &
				    rtol[j - 1], &atol[j - 1], &c__1, &istate,
				     &c__0, rwork, &lrw, iwork, &liw, &mf);
			}
			if (miter >= 4) {
			    dlsodi_((U_fp)res_, (U_fp)addabd_, (U_fp)jacbd_, &
				    n, y, ydoti, &t, &tout[io - 1], &itol, &
				    rtol[j - 1], &atol[j - 1], &c__1, &istate,
				     &c__0, rwork, &lrw, iwork, &liw, &mf);
			}
			io___49.ciunit = lout;
			s_wsfe(&io___49);
			do_fio(&c__1, (char *)&t, (ftnlen)sizeof(doublereal));
			do_fio(&c__1, (char *)&rwork[10], (ftnlen)sizeof(
				doublereal));
			do_fio(&c__1, (char *)&iwork[13], (ftnlen)sizeof(
				integer));
			i__2 = n;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    do_fio(&c__1, (char *)&y[i__ - 1], (ftnlen)sizeof(
				    doublereal));
			}
			e_wsfe();

/* If istate is not 2 on return, print message and loop. */
			if (istate != 2) {
			    io___50.ciunit = lout;
			    s_wsfe(&io___50);
			    do_fio(&c__1, (char *)&mf, (ftnlen)sizeof(integer)
				    );
			    do_fio(&c__1, (char *)&t, (ftnlen)sizeof(
				    doublereal));
			    do_fio(&c__1, (char *)&istate, (ftnlen)sizeof(
				    integer));
			    e_wsfe();
			    ++nerr;
			    goto L100;
			}

/* L80: */
		    }

		    io___51.ciunit = lout;
		    s_wsfe(&io___51);
		    do_fio(&c__1, (char *)&mf, (ftnlen)sizeof(integer));
		    do_fio(&c__1, (char *)&iwork[10], (ftnlen)sizeof(integer))
			    ;
		    do_fio(&c__1, (char *)&iwork[11], (ftnlen)sizeof(integer))
			    ;
		    do_fio(&c__1, (char *)&iwork[12], (ftnlen)sizeof(integer))
			    ;
		    do_fio(&c__1, (char *)&iwork[16], (ftnlen)sizeof(integer))
			    ;
		    do_fio(&c__1, (char *)&iwork[17], (ftnlen)sizeof(integer))
			    ;
		    e_wsfe();

/* Estimate final error and print result. */
		    errfac = elkup_(&n, y, &rwork[20], &itol, &rtol[j - 1], &
			    atol[j - 1]);
		    if (errfac > hun) {
			io___53.ciunit = lout;
			s_wsfe(&io___53);
			do_fio(&c__1, (char *)&errfac, (ftnlen)sizeof(
				doublereal));
			e_wsfe();
			++nerr;
		    } else {
			io___54.ciunit = lout;
			s_wsfe(&io___54);
			do_fio(&c__1, (char *)&errfac, (ftnlen)sizeof(
				doublereal));
			e_wsfe();
		    }
L100:
		    ;
		}
	    }
/* L200: */
	}
/* L300: */
    }

    io___55.ciunit = lout;
    s_wsfe(&io___55);
    do_fio(&c__1, (char *)&nerr, (ftnlen)sizeof(integer));
    e_wsfe();
    s_stop("", (ftnlen)0);







/* end of main program for the DLSODI demonstration problem. */
    return 0;
} /* MAIN__ */

/* Subroutine */ int res_(integer *n, doublereal *t, doublereal *y, 
	doublereal *v, doublereal *r__, integer *ires)
{
    /* Initialized data */

    static doublereal one = 1.;
    static doublereal four = 4.;
    static doublereal six = 6.;

    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int gfun_(integer *, doublereal *, doublereal *, 
	    doublereal *);
    static doublereal fact1, fact4;

/* This subroutine computes the residual vector */
/*   r = g(t,y) - A(t,y)*v . */
/* It uses nm1 = n - 1 from Common. */
/* If ires = -1, only g(t,y) is returned in r, since A(t,y) does */
/* not depend on y. */

    /* Parameter adjustments */
    --r__;
    --v;
    --y;

    /* Function Body */

    gfun_(n, t, &y[1], &r__[1]);
    if (*ires == -1) {
	return 0;
    }

    fact1 = one / six;
    fact4 = four / six;
    r__[1] -= fact4 * v[1] + fact1 * v[2];
    i__1 = test1_1.nm1;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* L10: */
	r__[i__] -= fact1 * v[i__ - 1] + fact4 * v[i__] + fact1 * v[i__ + 1];
    }
    r__[*n] -= fact1 * v[test1_1.nm1] + fact4 * v[*n];
    return 0;
/* end of subroutine res for the DLSODI demonstration problem. */
} /* res_ */

/* Subroutine */ int gfun_(integer *n, doublereal *t, doublereal *y, 
	doublereal *g)
{
    /* Initialized data */

    static doublereal two = 2.;

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__;

/* This subroutine computes the right-hand side function g(y,t). */
/* It uses r4d = 1/(4*delta), eodsq = eta/delta**2, and nm1 = n - 1 */
/* from the Common block test1. */

    /* Parameter adjustments */
    --g;
    --y;

    /* Function Body */

/* Computing 2nd power */
    d__1 = y[2];
    g[1] = -test1_1.r4d * (d__1 * d__1) + test1_1.eodsq * (y[2] - two * y[1]);

    i__1 = test1_1.nm1;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* Computing 2nd power */
	d__1 = y[i__ - 1];
/* Computing 2nd power */
	d__2 = y[i__ + 1];
	g[i__] = test1_1.r4d * (d__1 * d__1 - d__2 * d__2) + test1_1.eodsq * (
		y[i__ + 1] - two * y[i__] + y[i__ - 1]);
/* L20: */
    }

/* Computing 2nd power */
    d__1 = y[test1_1.nm1];
    g[*n] = test1_1.r4d * (d__1 * d__1) + test1_1.eodsq * (y[test1_1.nm1] - 
	    two * y[*n]);

    return 0;
/* end of subroutine gfun for the DLSODI demonstration problem. */
} /* gfun_ */

/* Subroutine */ int addabd_(integer *n, doublereal *t, doublereal *y, 
	integer *ml, integer *mu, doublereal *pa, integer *m0)
{
    /* Initialized data */

    static doublereal one = 1.;
    static doublereal four = 4.;
    static doublereal six = 6.;

    /* System generated locals */
    integer pa_dim1, pa_offset, i__1;

    /* Local variables */
    static integer i__, mup1, mup2;
    static doublereal fact1, fact4;

/* This subroutine computes the matrix A in band form, adds it to pa, */
/* and returns the sum in pa.   The matrix A is tridiagonal, of order n, */
/* with nonzero elements (reading across) of  1/6, 4/6, 1/6. */

    /* Parameter adjustments */
    --y;
    pa_dim1 = *m0;
    pa_offset = 1 + pa_dim1;
    pa -= pa_offset;

    /* Function Body */

/* Set the pointers. */
    mup1 = *mu + 1;
    mup2 = *mu + 2;
/* Compute the elements of A. */
    fact1 = one / six;
    fact4 = four / six;
/* Add the matrix A to the matrix pa (banded). */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	pa[*mu + i__ * pa_dim1] += fact1;
	pa[mup1 + i__ * pa_dim1] += fact4;
	pa[mup2 + i__ * pa_dim1] += fact1;
/* L10: */
    }
    return 0;
/* end of subroutine addabd for the DLSODI demonstration problem. */
} /* addabd_ */

/* Subroutine */ int addafl_(integer *n, doublereal *t, doublereal *y, 
	integer *ml, integer *mu, doublereal *pa, integer *m0)
{
    /* Initialized data */

    static doublereal one = 1.;
    static doublereal four = 4.;
    static doublereal six = 6.;

    /* System generated locals */
    integer pa_dim1, pa_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal fact1, fact4;

/* This subroutine computes the matrix A in full form, adds it to */
/* pa, and returns the sum in pa. */
/* It uses nm1 = n - 1 from Common. */
/* The matrix A is tridiagonal, of order n, with nonzero elements */
/* (reading across) of  1/6, 4/6, 1/6. */

    /* Parameter adjustments */
    --y;
    pa_dim1 = *m0;
    pa_offset = 1 + pa_dim1;
    pa -= pa_offset;

    /* Function Body */

/* Compute the elements of A. */
    fact1 = one / six;
    fact4 = four / six;

/* Add the matrix A to the matrix pa (full). */

    i__1 = test1_1.nm1;
    for (i__ = 2; i__ <= i__1; ++i__) {
	pa[i__ + (i__ + 1) * pa_dim1] += fact1;
	pa[i__ + i__ * pa_dim1] += fact4;
	pa[i__ + (i__ - 1) * pa_dim1] += fact1;
/* L110: */
    }
    pa[(pa_dim1 << 1) + 1] += fact1;
    pa[pa_dim1 + 1] += fact4;
    pa[*n + *n * pa_dim1] += fact4;
    pa[*n + test1_1.nm1 * pa_dim1] += fact1;
    return 0;
/* end of subroutine addafl for the DLSODI demonstration problem. */
} /* addafl_ */

/* Subroutine */ int jacbd_(integer *n, doublereal *t, doublereal *y, 
	doublereal *s, integer *ml, integer *mu, doublereal *pa, integer *m0)
{
    /* Initialized data */

    static doublereal two = 2.;

    /* System generated locals */
    integer pa_dim1, pa_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal r2d;
    static integer mup1, mup2;
    static doublereal diag;

/* This subroutine computes the Jacobian dg/dy = d(g-a*s)/dy */
/* and stores elements */
/*   i   j */
/* dg /dy   in  pa(i-j+mu+1,j)  in band matrix format. */
/* It uses r4d = 1/(4*delta), eodsq = eta/delta**2, and nm1 = n - 1 */
/* from the Common block test1. */

    /* Parameter adjustments */
    --s;
    --y;
    pa_dim1 = *m0;
    pa_offset = 1 + pa_dim1;
    pa -= pa_offset;

    /* Function Body */

    mup1 = *mu + 1;
    mup2 = *mu + 2;
    diag = -two * test1_1.eodsq;
    r2d = two * test1_1.r4d;
/*                     1   1 */
/* Compute and store dg /dy */
    pa[mup1 + pa_dim1] = diag;

/*                     1   2 */
/* Compute and store dg /dy */
    pa[*mu + (pa_dim1 << 1)] = -r2d * y[2] + test1_1.eodsq;

    i__1 = test1_1.nm1;
    for (i__ = 2; i__ <= i__1; ++i__) {

/*                     i   i-1 */
/* Compute and store dg /dy */
	pa[mup2 + (i__ - 1) * pa_dim1] = r2d * y[i__ - 1] + test1_1.eodsq;

/*                     i   i */
/* Compute and store dg /dy */
	pa[mup1 + i__ * pa_dim1] = diag;

/*                     i   i+1 */
/* Compute and store dg /dy */
	pa[*mu + (i__ + 1) * pa_dim1] = -r2d * y[i__ + 1] + test1_1.eodsq;
/* L20: */
    }

/*                     n   n-1 */
/* Compute and store dg /dy */
    pa[mup2 + test1_1.nm1 * pa_dim1] = r2d * y[test1_1.nm1] + test1_1.eodsq;

/*                     n   n */
/* Compute and store dg /dy */
    pa[mup1 + *n * pa_dim1] = diag;

    return 0;
/* end of subroutine jacbd for the DLSODI demonstration problem. */
} /* jacbd_ */

/* Subroutine */ int jacfl_(integer *n, doublereal *t, doublereal *y, 
	doublereal *s, integer *ml, integer *mu, doublereal *pa, integer *m0)
{
    /* Initialized data */

    static doublereal two = 2.;

    /* System generated locals */
    integer pa_dim1, pa_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal r2d, diag;

/* This subroutine computes the Jacobian dg/dy = d(g-a*s)/dy */
/* and stores elements */
/*   i   j */
/* dg /dy   in  pa(i,j) in full matrix format. */
/* It uses r4d = 1/(4*delta), eodsq = eta/delta**2, and nm1 = n - 1 */
/* from the Common block test1. */

    /* Parameter adjustments */
    --s;
    --y;
    pa_dim1 = *m0;
    pa_offset = 1 + pa_dim1;
    pa -= pa_offset;

    /* Function Body */

    diag = -two * test1_1.eodsq;
    r2d = two * test1_1.r4d;

/*                     1   1 */
/* Compute and store dg /dy */
    pa[pa_dim1 + 1] = diag;

/*                     1   2 */
/* Compute and store dg /dy */
    pa[(pa_dim1 << 1) + 1] = -r2d * y[2] + test1_1.eodsq;

    i__1 = test1_1.nm1;
    for (i__ = 2; i__ <= i__1; ++i__) {

/*                     i   i-1 */
/* Compute and store dg /dy */
	pa[i__ + (i__ - 1) * pa_dim1] = r2d * y[i__ - 1] + test1_1.eodsq;

/*                     i   i */
/* Compute and store dg /dy */
	pa[i__ + i__ * pa_dim1] = diag;

/*                     i   i+1 */
/* Compute and store dg /dy */
	pa[i__ + (i__ + 1) * pa_dim1] = -r2d * y[i__ + 1] + test1_1.eodsq;
/* L120: */
    }

/*                     n   n-1 */
/* Compute and store dg /dy */
    pa[*n + test1_1.nm1 * pa_dim1] = r2d * y[test1_1.nm1] + test1_1.eodsq;

/*                     n   n */
/* Compute and store dg /dy */
    pa[*n + *n * pa_dim1] = diag;

    return 0;
/* end of subroutine jacfl for the DLSODI demonstration problem. */
} /* jacfl_ */

doublereal elkup_(integer *n, doublereal *y, doublereal *ewt, integer *itol, 
	doublereal *rtol, doublereal *atol)
{
    /* Initialized data */

    static doublereal y9[9] = { .107001457,.277432492,.502444616,.721037157,
	    .901670441,.888832048,.49657285,.0946924362,-.00690855199 };
    static struct {
	doublereal e_1[99];
	} equiv_6 = { .00205114384, .00419527452, .00652533872, .00913412751, 
		.0121140191, .0155565301, .0195516488, .0241869487, 
		.0295465081, .0357096839, .0427498067, .0507328729, 
		.0597163151, .0697479236, .0808649804, .0930936515, 
		.106448659, .120933239, .136539367, .153248227, .171030869, 
		.189849031, .209656044, .230397804, .252013749, .274437805, 
		.297599285, .321423708, .345833531, .370748792, .396087655, 
		.421766871, .447702161, .473808532, .500000546, .526192549, 
		.552298887, .578234121, .603913258, .629252015, .654167141, 
		.67857679, .702400987, .725562165, .747985803, .769601151, 
		.790342031, .810147715, .828963844, .846743353, .863447369, 
		.879046021, .893519106, .906856541, .919058529, .930135374, 
		.940106872, .949001208, .956853318, .963702661, .969590361, 
		.974555682, .978631814, .981840924, .98418843, .985656465, 
		.986196496, .985721098, .984094964, .981125395, .976552747, 
		.970041743, .961175143, .949452051, .934294085, .915063568, 
		.891098383, .86176766, .826550038, .785131249, .737510044, 
		.68409254, .625748369, .563802368, .499946558, .436077986, 
		.374091566, .315672765, .262134958, .214330497, .172640946, 
		.137031155, .107140815, .082386792, .0620562432, .0453794321, 
		.0315789227, .019896882, .00960472135 };


    /* System generated locals */
    doublereal ret_val;

    /* Local variables */
    static integer i__;
#define y99 ((doublereal *)&equiv_6)
#define y99a ((doublereal *)&equiv_6)
#define y99b ((doublereal *)&equiv_6 + 16)
#define y99c ((doublereal *)&equiv_6 + 32)
#define y99d ((doublereal *)&equiv_6 + 48)
#define y99e ((doublereal *)&equiv_6 + 64)
#define y99f ((doublereal *)&equiv_6 + 80)
#define y99g ((doublereal *)&equiv_6 + 96)
    extern /* Subroutine */ int dewset_(integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, doublereal *);
    extern doublereal dvnorm_(integer *, doublereal *, doublereal *);

/* This routine looks up approximately correct values of y at t = 0.4, */
/* ytrue = y9 or y99 depending on whether n = 9 or 99.  These were */
/* obtained by running DLSODI with very tight tolerances. */
/* The returned value is */
/* elkup  =  norm of  ( y - ytrue ) / ( rtol*abs(ytrue) + atol ). */

    /* Parameter adjustments */
    --ewt;
    --y;

    /* Function Body */

    if (*n == 99) {
	goto L99;
    }

/* Compute local error tolerance using correct y (n = 9). */

    dewset_(n, itol, rtol, atol, y9, &ewt[1]);

/* Invert ewt and replace y by the error, y - ytrue. */

    for (i__ = 1; i__ <= 9; ++i__) {
	ewt[i__] = 1. / ewt[i__];
/* L20: */
	y[i__] -= y9[i__ - 1];
    }
    goto L200;

/* Compute local error tolerance using correct y (n = 99). */

L99:
    dewset_(n, itol, rtol, atol, y99, &ewt[1]);

/* Invert ewt and replace y by the error, y - ytrue. */

    for (i__ = 1; i__ <= 99; ++i__) {
	ewt[i__] = 1. / ewt[i__];
/* L120: */
	y[i__] -= y99[i__ - 1];
    }

/* Find weighted norm of the error and return. */

L200:
    ret_val = dvnorm_(n, &y[1], &ewt[1]);
    return ret_val;
/* end of function elkup for the DLSODI demonstration program. */
} /* elkup_ */

#undef y99g
#undef y99f
#undef y99e
#undef y99d
#undef y99c
#undef y99b
#undef y99a
#undef y99


